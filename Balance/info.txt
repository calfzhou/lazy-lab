如果不能使用高精度数字，那就要考虑整数溢出的问题，实际上任何两个同符号整数相加都有可能溢出，何况是上GB的数据呢。

基本的思想還是一样的，从数组左端开始寻找其和等于数组总和两倍的子数组，只是要避免让两个同符号数相加或者两个异符号数相减。

设原数组为A，假设存在一个数组AA，每个元素都是A中对应元素的两倍。

假设数组里都是正数，那只要用类似于归并的方法，从A和AA的最左端开始依次相互抵消，比如：
A = [5, 8, 13], AA = [10, 16, 26]
那么先拿5和10比较，用大的减去小的，丢掉小的，结果这两个数组就变成：
A = [8, 13], AA = [5, 16, 26]
然后在用8和5比，大的减去小的，丢掉小的，得到：
A = [3, 13], AA = [16, 26]
以此类推：
A = [13], AA = [13, 26]
A = [], AA = [26]
到这个时候，A已经为空了，而AA恰好减少了左边两个元素（第三个元素还没有被减小），所以原数组中左边两个数字之两倍和等于原数组数字总和。这便是唯一的一个平衡点。

如果数组里有正数也有负数，可以先让A中的正负数相互抵消直至其中的一种数全部消失（假设负数全部消失）；而对于AA，遇到正数与A相消，遇到负数则内部相消（显然AA中的负数迟早会被消灭光）。当A为空时，如果AA恰好减少了左边若干个元素（可能有正有负），那这就是第一个平衡点。
由于负数的存在，这个平衡点右边可能还会有其他平衡点，那么只要让AA中的正负数继续相互抵消，直到再次出现恰好减少了左边若干个元素的时候，就又得到了一个新的平衡点。

注意两点：
1. 一个整数乘以2是有可能溢出的，所以实际的代码中不能做乘法，但可以有其他变通的方法。
2. 注意0这个讨厌的家伙，一个平衡点右边的数字如果是0，那么这里也是一个平衡点。

算法：
01. AA <- A * 2
02. while A中有正数 and A中有负数:
03.   A中正负数相互抵消
04. // 假设A中没有负数了
05. while A不为空:
06.   AA中正数与A中数字相互抵消
07. while true:
08.   if AA恰好减少了左边m个元素:
09.     m是一个平衡点
10.     m右边连续的0都是平衡点
11.   if AA为空
12.     break
13.   if AA中有负数:
14.     AA中正负数相互抵消

八卦：
仔细想想这个算法，是不是很像一部武侠小说？概要如下：
一日武林英雄齐聚一堂，推选武林盟主，peter和neil两位大侠的武功和资历都是顶尖级的，也只有这两人有可能成为武林盟主，于是二人比武过招。
所谓外行看热闹，内行看门道，在坐的各位都是练家子，俺也就不多废话了。
长话短说，一番打斗之后，neil终于败下阵来，胜利者peter成为武林盟主。
可就在这时，从台下窜上来一个西域歹人robber，气血沸腾，杀气逼人。此人一面大喊：“中原武林不过如此，吃俺这招”一面直逼peter。peter毕竟上了些年纪，刚刚打完一阵尚未恢复妥当，被这歹人杀得是毫无还手之力，几个回合之后，peter便被robber一掌劈飞出擂台，摔在地上人事不醒。
robber气焰极其嚣张，在台上破口大骂中原武林，台下的好汉真是无法忍受，可是却也无能为力。几百年前冷兵器逐渐没落，中原武术大多早已失传，除了peter和neil之外，其他人都只是会些防身用的皮毛拳脚。
就在这时，远处马蹄声起，众人循声望去，无不面露喜色。原来刚才robber刚登台时就有人给官府送了信，来的此人正是本地赫赫有名的武将soldier。soldier是个年轻漂亮的小伙儿，也是气血方刚。离着擂台还有三丈远呢，他脚尖一点马蹬，嗖地就飞上擂台，二话不说跟robber打作一团。
但是很快众人脸上的笑容就停住了，soldier根本不是robber的对手，被robber逼得只有招架之力。十几个回合之后，robber一拳打在soldier胸口，soldier口喷鲜血，一头栽倒。robber轻蔑地看了他一眼，收身站好。可就在这时，soldier颤抖着手从腰间摸出火枪，对着robber的头就是一枪。砰！
